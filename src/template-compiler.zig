const std = @import("std");
const compiled = @import("templates-compiled");
const Template = @import("template.zig");

pub fn main() !void {
    var args = std.process.args();

    var wout_path: ?[]const u8 = null;
    while (args.next()) |arg| {
        wout_path = arg;
    }

    const wout_dname = std.fs.path.dirname(wout_path.?) orelse return error.InvalidPath;
    const wout_dir = try std.fs.cwd().openDir(wout_dname, .{});
    var wout = try wout_dir.createFile(std.fs.path.basename(wout_path.?), .{});
    defer wout.close();
    try wout.writeAll(
        \\// Generated by srctree template compiler
        \\
    );
    for (compiled.data) |tplt| {
        std.debug.print("thing: {s}\n", .{tplt.path});
        try wout.writeAll("pub const ");
        try wout.writeAll(makeStructName(tplt.path));
        try wout.writeAll(" = struct {\n");
        try collectVars(tplt.path, wout);
        try wout.writeAll("};\n\n");
    }
}

fn collectVars(fstr: []const u8, w: std.fs.File) !void {
    var a = std.heap.page_allocator;
    const fdata = try std.fs.cwd().readFileAlloc(a, fstr, 0xffff);
    defer a.free(fdata);

    var data = fdata;
    while (data.len > 0) {
        if (std.mem.indexOf(u8, data, "<")) |offset| {
            data = data[offset..];
            if (Template.Directive.init(data)) |drct| switch (drct.kind) {
                .noun => |noun| {
                    data = data[drct.end..];
                    try w.writeAll("    ");
                    switch (noun.otherwise) {
                        .ign => {
                            try w.writeAll(noun.vari);
                            try w.writeAll(": []const u8,\n");
                        },
                        .str => |str| {
                            try w.writeAll(noun.vari);
                            try w.writeAll(": []const u8 = ");
                            try w.writeAll(str);
                            try w.writeAll(",\n");
                        },
                        .del => {
                            try w.writeAll(noun.vari);
                            try w.writeAll(": ?[]const u8 = null,\n");
                        },
                        .template => |_| {
                            try w.writeAll(noun.vari[1 .. noun.vari.len - 5]);
                            try w.writeAll(": ");
                            try w.writeAll(makeStructName(noun.vari));
                            try w.writeAll(",\n");
                        },
                    }
                },
                .verb => |verb| {
                    data = data[drct.end..];
                    try w.writeAll("    // Verb ");
                    try w.writeAll(verb.vari);
                    try w.writeAll("\n");
                },
            } else if (std.mem.indexOfPos(u8, data, 1, "<")) |next| {
                data = data[next..];
            } else return;
        } else return;
    }
}

pub fn makeStructName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var tail = in;

    if (std.mem.lastIndexOf(u8, in, "/")) |i| {
        tail = tail[i..];
    }

    var i: usize = 0;
    var next_upper = true;
    for (tail) |chr| {
        switch (chr) {
            'a'...'z', 'A'...'Z' => {
                if (next_upper) {
                    local.name[i] = std.ascii.toUpper(chr);
                } else {
                    local.name[i] = std.ascii.toLower(chr);
                }
                next_upper = false;
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_' => {
                next_upper = true;
            },
            '.' => break,
            else => {},
        }
    }

    return local.name[0..i];
}

fn intToWord(in: u8) []const u8 {
    return switch (in) {
        '4' => "Four",
        '5' => "Five",
        else => unreachable,
    };
}
