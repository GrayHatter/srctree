const std = @import("std");
const compiled = @import("templates-compiled");

pub fn main() !void {
    var args = std.process.args();

    var wout_path: ?[]const u8 = null;
    while (args.next()) |arg| {
        wout_path = arg;
    }

    const wout_dname = std.fs.path.dirname(wout_path.?) orelse return error.InvalidPath;
    const wout_dir = try std.fs.cwd().openDir(wout_dname, .{});
    var wout = try wout_dir.createFile(std.fs.path.basename(wout_path.?), .{});
    defer wout.close();
    try wout.writeAll(
        \\// Generated by srctree template compiler
        \\
    );
    for (compiled.data) |tplt| {
        std.debug.print("thing: {s}\n", .{tplt.path});
        try wout.writeAll("pub const ");
        try wout.writeAll(makeStructName(tplt.path));
        try wout.writeAll(" = struct {\n};\n\n");
    }
}

pub fn makeStructName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var tail = in;

    if (std.mem.lastIndexOf(u8, in, "/")) |i| {
        tail = tail[i..];
    }

    var i: usize = 0;
    var next_upper = true;
    for (tail) |chr| {
        switch (chr) {
            'a'...'z', 'A'...'Z' => {
                if (next_upper) {
                    local.name[i] = std.ascii.toUpper(chr);
                } else {
                    local.name[i] = std.ascii.toLower(chr);
                }
                next_upper = false;
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_' => {
                next_upper = true;
            },
            '.' => break,
            else => {},
        }
    }

    return local.name[0..i];
}

fn intToWord(in: u8) []const u8 {
    return switch (in) {
        '4' => "Four",
        '5' => "Five",
        else => unreachable,
    };
}
