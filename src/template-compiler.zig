const std = @import("std");
const compiled = @import("templates-compiled");
const Template = @import("template.zig");

pub fn main() !void {
    var args = std.process.args();

    var wout_path: ?[]const u8 = null;
    while (args.next()) |arg| {
        wout_path = arg;
    }

    const wout_dname = std.fs.path.dirname(wout_path.?) orelse return error.InvalidPath;
    const wout_dir = try std.fs.cwd().openDir(wout_dname, .{});
    var wout = try wout_dir.createFile(std.fs.path.basename(wout_path.?), .{});
    defer wout.close();
    try wout.writeAll(
        \\// Generated by srctree template compiler
        \\
    );
    for (compiled.data) |tplt| {
        std.debug.print("thing: {s}\n", .{tplt.path});
        try wout.writeAll("pub const ");
        try wout.writeAll(makeStructName(tplt.path));
        try wout.writeAll(" = struct {\n");
        const fwriter = wout.writer().any();
        const trailing = try emitVars(tplt.path, fwriter);
        defer std.heap.page_allocator.free(trailing);
        try wout.writeAll(trailing);

        try wout.writeAll("};\n\n");
    }
}

fn emitVars(fstr: []const u8, w: std.io.AnyWriter) ![]u8 {
    var a = std.heap.page_allocator;
    const fdata = try std.fs.cwd().readFileAlloc(a, fstr, 0xffff);
    defer a.free(fdata);

    var trailing = std.ArrayList(u8).init(a);

    var data = fdata;
    while (data.len > 0) {
        if (std.mem.indexOf(u8, data, "<")) |offset| {
            data = data[offset..];
            if (Template.Directive.init(data)) |drct| switch (drct.kind) {
                .noun => |noun| {
                    data = data[drct.end..];
                    try w.writeAll("    ");
                    switch (noun.otherwise) {
                        .ign => {
                            try w.writeAll(makeFieldName(noun.vari));
                            try w.writeAll(": []const u8,\n");
                        },
                        .str => |str| {
                            try w.writeAll(makeFieldName(noun.vari));
                            try w.writeAll(": []const u8 = ");
                            try w.writeAll(str);
                            try w.writeAll(",\n");
                        },
                        .del => {
                            try w.writeAll(makeFieldName(noun.vari));
                            try w.writeAll(": ?[]const u8 = null,\n");
                        },
                        .template => |_| {
                            try w.writeAll(noun.vari[1 .. noun.vari.len - 5]);
                            try w.writeAll(": ");
                            try w.writeAll(makeStructName(noun.vari));
                            try w.writeAll(",\n");
                        },
                    }
                },
                .verb => |verb| {
                    data = data[drct.end..];
                    try trailing.appendSlice("    pub const ");
                    try trailing.appendSlice(makeStructName(verb.vari));
                    try trailing.appendSlice(" = {\n");
                    switch (verb.word) {
                        .foreach => {
                            try w.writeAll("    // For ");
                            try w.writeAll(verb.vari);
                            try w.writeAll("\n");
                            try w.writeAll("    ");
                            try w.writeAll(makeFieldName(verb.vari));
                            try w.writeAll(": []");
                            try w.writeAll(verb.vari);
                            try w.writeAll(",\n");
                            const this_writer = trailing.writer().any();
                            emitVars(verb.blob, this_writer);
                        },
                        .with => {
                            try w.writeAll("    // With ");
                            try w.writeAll(verb.vari);
                            try w.writeAll("\n");
                        },
                    }
                    try trailing.appendSlice("    };\n");
                },
            } else if (std.mem.indexOfPos(u8, data, 1, "<")) |next| {
                data = data[next..];
            } else return try trailing.toOwnedSlice();
        } else return try trailing.toOwnedSlice();
    }
    return try trailing.toOwnedSlice();
}

pub fn makeFieldName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var i: usize = 0;
    for (in) |chr| {
        switch (chr) {
            'a'...'z' => {
                local.name[i] = chr;
                i += 1;
            },
            'A'...'Z' => {
                if (i != 0) {
                    local.name[i] = '_';
                    i += 1;
                }
                local.name[i] = std.ascii.toLower(chr);
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_', '.' => {
                local.name[i] = '_';
                i += 1;
            },
            else => {},
        }
    }

    return local.name[0..i];
}

pub fn makeStructName(in: []const u8) []const u8 {
    const local = struct {
        var name: [0xFFFF]u8 = undefined;
    };

    var tail = in;

    if (std.mem.lastIndexOf(u8, in, "/")) |i| {
        tail = tail[i..];
    }

    var i: usize = 0;
    var next_upper = true;
    for (tail) |chr| {
        switch (chr) {
            'a'...'z', 'A'...'Z' => {
                if (next_upper) {
                    local.name[i] = std.ascii.toUpper(chr);
                } else {
                    local.name[i] = std.ascii.toLower(chr);
                }
                next_upper = false;
                i += 1;
            },
            '0'...'9' => {
                for (intToWord(chr)) |cchr| {
                    local.name[i] = cchr;
                    i += 1;
                }
            },
            '-', '_' => {
                next_upper = true;
            },
            '.' => break,
            else => {},
        }
    }

    return local.name[0..i];
}

fn intToWord(in: u8) []const u8 {
    return switch (in) {
        '4' => "Four",
        '5' => "Five",
        else => unreachable,
    };
}
